#!/bin/bash
#
#                         License
#
# Copyright (C) 2021
#	David Valin dvalin@redhat.com
#	Sanjay Rao  srao@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
# Automates the installation and execution of the hammerdb tests, mariadb, postgress and
# mssql.
#
set -u
mountpoint=
log_mount_point=""
disklist=
warehousecount=""
#usercount="10 20 40 80 100"
usercount=(10 20 40)
tests_to_run=()
rundate=$(date +%Y.%m.%d.%H.%M.%S)
do_install=1
do_build=1
do_run=1
do_cleanup=1
install_packages=' '
instdir=/var/local/HammerDB
hostname=$(hostname)
memorykb=

. "${0%/*}"/do_service

usage()
{
	[[ -n "$*" ]] && echo "$*"
	cat <<EOF
Usage:
./run_hammerdb.sh [options...] [install] [run] [cleanup]
Usage:
  -h help
  -d <device > - default none
  -m <mount points> - default none
  -t <test to run> mariadb/postgres/mssql
  -u <user count> - default "${usercount[*]}"
  -w <warehouse count> - default 500 for postgres and mssql, 1000 for mariadb

  Examples:"
  ./run_hammerdb.sh -t mariadb
  ./run_hammerdb.sh -t postgres
  ./run_hammerdb.sh -d "/dev/vdb" -t mssql
  ./run_hammerdb.sh -m "/perf1" -t mariadb
  ./run_hammerdb.sh -m "/perf1" -w 100 -u "10 20" -t mariadb
EOF
	exit
}

#
# Generic routines
#
mount_check()
{
	[[ -n "${mountpoint:-}" || -n "${disklist:?Please specify a disk device or Mount Point}" ]]
}

doit() {
	local OPTIND=0
	local do_time=1
	while getopts ny opt "$@" ; do
		case "$opt" in
			n) do_time=0 ;;
			y) do_time=1 ;;
			*)           ;;
		esac
	done
	shift "$((OPTIND-1))"
	local __start=$(date +%s%N)
	"$@"
	local status=$?
	if ((status == 120 || do_time == 0)) ; then
		return 0
	elif ((status == 0)) ; then
		local __end=$(date +%s%N)
		local e=$((__end-__start))
		if ((${#e} < 10)) ; then
			e=0000000000$e
			e=0.${e:$((${#e}-9)):3}
		else
			e=${e:0:-9}.${e:$((${#e}-9)):3}
		fi
		echo "Elapsed $e $hostname $*"
		return 0
	else
		return $status
	fi
}

#
# Invoke the install script on the proper system
#
install_it()
{
	((do_install)) || return 120
	local service=
	local OPTIND=0
	while getopts b:s:t: opt "$@" ; do
		case "$opt" in
			s) service=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to install}
	local installp=${install_packages:+-p}${install_packages:--P}
	if [[ -n "${mountpoint:-}" ]]; then
		rm -rf "${mountpoint:?}/$test"
		# shellcheck disable=SC2086
		/var/tmp/hammerdb/install-script -i "$instdir" -m "${mountpoint:?}/$test" ${installp} ${memorykb:+-K "$memorykb"} -t "$test" ${log_mount_point}
	else
		# shellcheck disable=SC2086
		/var/tmp/hammerdb/install-script -i "$instdir" -d "$disklist" ${installp} ${memorykb:+-K "$memorykb"} -t "$test" ${log_mount_point}
	fi
	if [[ -n "$service" ]] ; then do_service restart "$service"; fi
}

build_it() {
	((do_build)) || return 120
	cd "${instdir}" || return 1
	local -i wait_time=0
	local build_command=
	local OPTIND=0
	while getopts b:t: opt "$@" ; do
		case "$opt" in
			t) wait_time=$OPTARG ;;
			b) build_command=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to build}
	if [[ -n "$build_command" ]] ; then
		sleep "$wait_time"
		"$build_command"
	fi
}

#
# Clean up the temporary database
#
clean_it() {
	((do_cleanup)) || return 120
	local service=
	local OPTIND=0
	while getopts s: opt "$@" ; do
		case "$opt" in
			s) service=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to uninstall}

	[[ -n "$service" ]] && do_service stop "$service"
	rm -rf "${mountpoint:?}/$test"
	echo "$test cleaned up"
	# Runtime is not interesting for cleanup
	return 120
}

#
# General run
#
run_hammerdb_users()
{
	local uc=${1:?Missing user count to run}
	local test=${2:?Missing test name to run}
	local tname=$test
	[[ $test = postgres ]] && tname=pg
	#
	# Due to the cloud systems, not logging in as root, we need two separate areas.  One
	# that operates on remote systems, the other that operate on the system we are currently
	# running on.
	cd "${instdir}" || exit
	pwd
	runtestfile=runtest_${test}_1.tcl
	outfile=test_${test}_${rundate}_${uc}.out
	resultfile=results_hammerdb_${test}.csv
	cp "runtest_${tname}.tcl" "$runtestfile"

	case "$test" in
		mariadb)
			sed -i "s/^diset connection mysql_host.*/diset connection mysql_host localhost/" "$runtestfile"
			;;
		mssql)
 			sed -i "s/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/" "$runtestfile"
			;;
		postgres)
			sed -i "s/^diset connection pg_host.*/diset connection pg_host localhost/" "$runtestfile"
			;;
	esac
	sed -i "s/^vuset.*/vuset vu ${uc}/" "$runtestfile"
	./hammerdbcli auto "$runtestfile" 2>&1 | tr '\r' '\n' > "$outfile"
	[[ -f "$resultfile" ]] || echo "# connection:TPM" > "$resultfile"
	shopt -s nullglob
	for file in "test_${test}_${rundate}_"*.out ; do
		connections=$(grep "Active Virtual Users configured" "$file" | cut -d: -f 2 | cut -d' ' -f 1)
		tpms=$(grep TPM "$file" | cut -d' ' -f 7)
		echo "${connections}:${tpms}" >> "$resultfile"
	done
	echo "${uc} User run for $test done"
	cat "$resultfile"
}

#
# Walk through the user count and run hammerdb
#
run_hammerdb()
{
	((do_run)) || return 120
	local uc
	for uc in "${usercount[@]}" ; do
		 run_hammerdb_users "$uc" "$@" || return 1
	done
}

#
# Install the install script as required.
#
install_install_script()
{
	mkdir -p /var/tmp/hammerdb
	cp -p do_service /var/tmp/hammerdb
	cp -p install-script /var/tmp/hammerdb
}

mariadb_build()
{
	mysql -p100yard- -e 'drop database tpcc;'
	cd "${instdir}" || exit
       	cp build_mariadb.tcl build_mariadb_1.tcl
	sed -i -e "s/^diset connection mysql_host.*/diset connection mysql_host localhost/" \
	    -e    "s/^diset tpcc mysql_count_ware.*/diset tpcc mysql_count_ware ${warehousecount}/" build_mariadb_1.tcl
	./hammerdbcli auto build_mariadb_1.tcl 2>&1 | tr '\r' '\n' > build_mariadb_pod.out
}

mariadb_test()
{
	warehousecount=${warehousecount:-1000}
	doit install_it -s mariadb.service mariadb || return 1
	doit build_it -b mariadb_build mariadb || return 1
	doit run_hammerdb mariadb || return 1
	doit clean_it -s mariadb.service mariadb || return 1
}

mssql_build()
{
	cd "${instdir}" || exit
	cp build_mssql.tcl build_mssql_1.tcl
	sed -i "s/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/" build_mssql.tcl
	./hammerdbcli auto build_mssql_1.tcl 2>&1  | tr '\r' '\n' > build_mssql.out
}

mssql_test()
{
	warehousecount=${warehousecount:-500}
	doit install_it -s mssql-server.service mssql || return 1
	doit build_it -t 60 -b mssql_build mssql || return 1
	doit run_hammerdb mssql || return 1
	doit clean_it -s mssql-server.service mssql || return 1
}

postgres_build()
{
	echo 'DROP DATABASE tpcc;' > input
	echo 'DROP ROLE tpcc;' >> input
	/usr/bin/psql -U postgres -d postgres -h "localhost" -f input
	cd "${instdir}" || exit 1
	cp build_pg.tcl build_pg_1.tcl
	sed -i "s/^diset connection pg_host.*/diset connection pg_host localhost/" build_pg_1.tcl
	./hammerdbcli auto build_pg_1.tcl 2>&1 | tr '\r' '\n' > build_pg.out
}

postgres_test()
{
	warehousecount=${warehousecount:-500}
	doit install_it -s postgresql.service postgres || return 1
	doit build_it -t 60 -b postgres_build postgres || return 1
	doit run_hammerdb postgres || return 1
	doit clean_it -s postgresql.service postgres || return 1
}

list_results_only()
{
	cd "${instdir}" || exit 1
	shopt -s nullglob
	local t_py
	t_py=$(mktemp -p /var/tmp -t "run_hammerdbXXXXXX.py") || exit 1
	cat > "$t_py" <<'EOF'
#!/usr/bin/python3

import json
import sys
import re

a = { "hostname": sys.argv[1], "hammerdb_results": [] }

rundate = sys.argv[2]

for file in sys.argv[3:]:
    m = re.match(rf'^test_([a-zA-Z0-9]+)_{rundate}_([0-9]+)\.out$', file)
    if m is not None:
        database = m[1]
        users = m[2]
        with open(file) as f:
            for line in f.readlines():
                if re.match(r'TEST', line) is not None:
                    print(line)
                m = re.match(r'Vuser ([0-9]+):TEST RESULT : System achieved ([0-9]+) .* TPM at ([0-9]+) NOPM$', line)
                if m is not None:
                    answer = {
                        "database": database,
                        "users": users,
                        "vuser": int(m[1]),
                        "tpm": int(m[2]),
                        "nopm": int(m[3])
                    }
                    a["hammerdb_results"].append(answer)

print(json.dumps(a))
EOF
	chmod +x "$t_py"
	"$t_py" "$(hostname)" "$rundate" test_*_"${rundate}"_*.out
	rm -f "$t_py"
	exit
}

#
# Were we passed an argument?
#

while getopts 'lhd:M:m:w:u:t:r:i:PpK:sSM:' opt "$@" ; do
	# shellcheck disable=SC2206
	case "$opt" in
		K) memorykb="$OPTARG" ;;
		M) log_mount_point=$OPTARG ;;
		P) install_packages='' ;;
		d) disklist=$OPTARG ;;
		i) instdir=$OPTARG ;;
		l) list_results_only ;;
		m) mountpoint=$OPTARG ;;
		p) install_packages=' ' ;;
		r) rundate=$OPTARG ;;
		s) _does_support_systemctl=1 ;;
		S) _does_support_systemctl=0 ;;
		t) tests_to_run+=(${OPTARG//,/ }) ;;
		u) usercount=(${OPTARG//,/ } ) ;;
		w) warehousecount=$OPTARG ;;
		h|*) usage "Unexpected option '$opt'" ;;
	esac
done
export _does_support_systemctl

shift $((OPTIND-1))
if [[ -n "$*" ]] ; then
	do_install=0
	do_build=0
	do_run=0
	do_cleanup=0
	for arg in "$@" ; do
		case "$arg" in
			install) do_install=1 ;;
			build) do_build=1 ;;
			run) do_run=1 ;;
			cleanup) do_cleanup=1 ;;
			*) usage "Unexpected argument $arg" ;;
		esac
	done
fi

#
# If no test to run designated, bail.
#
[[ -z "${tests_to_run[*]:-}" ]] && usage "You need to designate a test to run"

cd "${0%/*}" || usage "Cannot cd ' '${0%/*}' ($0}"

((do_install)) && install_install_script
mount_check
#
# Determine what we are to run and run it.
#
for test in "${tests_to_run[@]}" ; do
	case "$test" in
		mariadb*) mariadb_test ;;
		mssql) mssql_test ;;
		postgres*) postgres_test ;;
		*) usage "Unknown test $test"
	esac
done

# Local Variables:
# sh-indentation: 8
# End:
