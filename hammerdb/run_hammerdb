#!/bin/bash
#
#                         License
#
# Copyright (C) 2021
#	David Valin dvalin@redhat.com
#	Sanjay Rao  srao@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
# Automates the installation and execution of the hammerdb tests, mariadb, postgress and
# mssql.
#
set -u
mountpoint=
log_mount_point=""
disklist=
warehousecount=""
#usercount="10 20 40 80 100"
usercount="10 20 40"
tests_to_run=()
dbhosts=()
rundate=$(date +%Y.%m.%d.%H.%M.%S)
do_install=1
do_build=1
do_run=1
do_cleanup=1
install_packages=' '
usage()
{
	[[ -n "$*" ]] && echo "$*"
	cat <<EOF
HOST NAME or IP REQUIRED!! - see usage below
Usage:
./run_hammerdb.sh [options...] [install] [run] [cleanup]
Usage:
  -h help
  -H <Host names separated by space> - default 127.0.0.1
  -d <device > - default none
  -m <mount points> - default none
  -t <test to run> mariadb/postgres/mssql
  -u <user count> - default "$usercount"
  -w <warehouse count> - default 500 for postgres and mssql, 1000 for mariadb

  Examples:"
  ./run_hammerdb.sh -H "dhcp31-32 dhcp31-33" -t mariadb
  ./run_hammerdb.sh -H "10.16.31.32 10.16.31.33" -t postgres
  ./run_hammerdb.sh -H "10.16.31.32 10.16.31.33" -d "/dev/vdb" -t mssql
  ./run_hammerdb.sh -H "10.16.31.32 10.16.31.33" -m "/perf1" -t mariadb
  ./run_hammerdb.sh -H "dhcp31-32 dhcp31-33" -m "/perf1" -w 100 -u "10 20" -t mariadb
EOF
	exit
}

#
# Generic routines
#
mount_check()
{
	[[ -n "${mountpoint:-}" || -n "${disklist:?Please specify a disk device or Mount Point}" ]]
}

timeit() {
	local __start=$(date +%s%N)
	"$@"
	local __end=$(date +%s%N)
	local e=$((__end-__start))
	if ((${#e} < 10)) ; then
		e=0000000000$e
		e=0.${e:$((${#e}-9)):3}
	else
		e=${e:0:-9}.${e:$((${#e}-9)):3}
	fi
	echo "Elapsed $e $*"
}

#
# Invoke the install script on the proper system
#
install_it()
{
	((do_install)) || return
	local service=
	local OPTIND=0
	while getopts b:s:t: opt "$@" ; do
		case "$opt" in
			s) service=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to install}
	local installp=${install_packages:+-p}${install_packages:--P}
	if [[ -n "${dbhosts[*]:-}" ]] ; then
		echo "Remote install"
		#
		# Remote systems
		#
		local host
		for host in "${dbhosts[@]}"; do
			if [[ -z "${mountpoint:-}" ]]; then
				ssh -n "root@${host}" "/root/install-script -d '${disklist}' ${installp} -t '$test' ${log_mount_point}" &
			else
				ssh -n "root@${host}" "rm -rf '${mountpoint:?}/${test}'"
				ssh -n "root@${host}" "/root/install-script -m '${mountpoint:?}/${test}' ${installp} -t '$test' ${log_mount_point}" &
			fi
		done
		wait
		if [[ -n "$service" ]] ; then
			for host in "${dbhosts[@]}"; do
				ssh -n "root@$host" systemctl restart "$service" &
			done
			wait
		fi
	else
		echo "Local install"
		#
		# Local system
		#
		if [[ -n "${mountpoint:-}" ]]; then
			rm -rf "${mountpoint:?}/$test"
			# shellcheck disable=SC2086
			/root/install-script -m "${mountpoint:?}/$test" ${installp} -t "$test" ${log_mount_point}
		else
			# shellcheck disable=SC2086
			/root/install-script -d "$disklist" ${installp} -t "$test" ${log_mount_point}
		fi
		[[ -n "$service" ]] && systemctl restart "$service"
	fi
}

build_it() {
	((do_build)) || return
	cd /usr/local/HammerDB || exit
	local -i wait_time=0
	local build_command=
	local OPTIND=0
	while getopts b:t: opt "$@" ; do
		case "$opt" in
			t) wait_time=$OPTARG ;;
			b) build_command=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to build}
	if [[ -n "$build_command" ]] ; then
		sleep "$wait_time"
		"$build_command"
	fi
}

#
# Clean up the temporary database
#
clean_it() {
	((do_cleanup)) || return
	local service=
	local OPTIND=0
	while getopts s: opt "$@" ; do
		case "$opt" in
			s) service=$OPTARG ;;
			*) ;;
		esac
	done
	shift $((OPTIND-1))
	local test=${1:?Missing test name to uninstall}

	if [[ -n "$service" ]] ; then
		if [[ -n "${dbhosts[*]:-}" ]] ; then
			local host
			for host in "${dbhosts[@]}" ; do
				ssh -n "root@$host" "systemctl stop '$service'"
			done
		else
			systemctl stop "$service"
		fi
	fi

	if [[ -n "${mountpoint:-}" ]] ; then
		if [[ -n "${dbhosts[*]:-}" ]] ; then
			#
			# Remote systems
			#
			local host
			for host in "${dbhosts[@]}}"; do
				ssh -n "root@${host}" "rm -rf '${mountpoint:?}/${test}'"
			done
		else
			#
			# Local system
			#
			rm -rf "${mountpoint:?}/$test"
		fi
	fi
	echo "$test cleaned up"
}

#
# General run
#
run_hammerdb_users()
{
	local -i ctr=1
	local uc=${1:?Missing user count to run}
	local test=${2:?Missing test name to run}
	local tname=$test
	[[ $test = postgres ]] && tname=pg
	#
	# Due to the cloud systems, not logging in as root, we need two separate areas.  One
	# that operates on remote systems, the other that operate on the system we are currently
	# running on.
	cd /usr/local/HammerDB || exit
	local -i numhosts=${#dbhosts[@]}
	if [[ -n "${dbhosts[*]:-}" ]]; then
		local host
		for host in "${dbhosts[@]}" ;do
			runtestfile=runtest${ctr}_${test}.tcl
			outfile=test_${test}_${rundate}_n${numhosts}_i${ctr}_${uc}.out
			ssh -n "root@$host" "cd /usr/local/HammerDB && cp 'runtest_${tname}.tcl' '$runtestfile'"
			case "$test" in
				mariadb)
					ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^diset connection mysql_host.*/diset connection mysql_host ${host}/' '$runtestfile'"
					;;
				mssql)
					ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/' '$runtestfile"
					;;
				postgres)
					ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^diset connection pg_host.*/diset connection pg_host ${host}/' '$runtestfile'"
					;;
			esac
			ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^vuset.*/vuset vu ${uc}/' '$runtestfile'"
			ssh -n "root@$host" "cd /usr/local/HammerDB; nohup ./hammerdbcli auto '$runtestfile'" 2>&1 | tr '\r' '\n' > "$outfile" &
			ctr=$((ctr + 1))
		done
		#
		# Wait for everyone to complete.
		#
		wait
		#
		# Give things a chance to settle down.
		#
		sleep 120
	else
		runtestfile=runtest${ctr}_${test}.tcl
		outfile=test_${test}_${rundate}_n${ctr}_i${ctr}_${uc}.out
		resultfile=results_hammerdb_${test}.csv
		echo "Outfile is $outfile"
		echo "runtestfile is $runtestfile"
		cp "runtest_${tname}.tcl" "$runtestfile"

		case "$test" in
			mariadb)
				sed -i "s/^diset connection mysql_host.*/diset connection mysql_host localhost/" "$runtestfile"
				;;
			mssql)
 				sed -i "s/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/" "$runtestfile"
				;;
			postgres)
				sed -i "s/^diset connection pg_host.*/diset connection pg_host localhost/" "$runtestfile"
				;;
		esac
		sed -i "s/^vuset.*/vuset vu ${uc}/" "$runtestfile"
		./hammerdbcli auto "$runtestfile" 2>&1 | tr '\r' '\n' > "$outfile" 2>&1
		grep TPM "$outfile" | awk '{print $7}'
		[[ -f "$resultfile" ]] || echo "# connection:TPM" > "$resultfile"
		shopt -s nullglob
		for file in "test_${test}_${rundate}_"*.out ; do
			connections=$(grep "Active Virtual Users configured" "$file" | cut -d: -f 2 | cut -d' ' -f 1)
			tpms=$(grep TPM "$file" | cut -d' ' -f 7)
			echo "${connections}:${tpms}" >> "$resultfile"
		done
	fi
	echo "${uc} User run for $test done"
}

#
# Walk through the user count and run hammerdb
#
run_hammerdb()
{
	((do_run)) || return
	local uc
	for uc in $usercount ; do
		 run_hammerdb_users "$uc" "$@"
	done
}

#
# Install the install script as required.
#
install_install_script()
{
	if [[ -n "${dbhosts[*]:-}" ]] ; then
		#
		# copy scripts to the VMS
		#
		local host
		for host in "${dbhosts[@]}" ; do
			scp install-script "root@${host}:/root"
		done
	else
		#
		# copy the script to root
		#
		cp install-script /root
	fi
}

mariadb_build()
{
	local -i ctr=1
	if [[ -n "${dbhosts[*]:-}" ]] ; then
		local host
		for host in "${dbhosts[@]}" ; do
			ssh -n "root@$host" "mysql -p100yard- -e 'drop database tpcc;'"
			ssh -n "root@$host" "cd /usr/local/HammerDB && cp build_mariadb.tcl 'build${ctr}_mariadb.tcl'"
			ssh -n "root@$host" "cd /usr/local/HammerDB && sed -i 's/^diset connection mysql_host.*/diset connection mysql_host ${host}/' 'build${ctr}_mariadb.tcl'"
			ssh -n "root@$host" "cd /usr/local/HammerDB && sed -i 's/^diset tpcc mysql_count_ware.*/diset tpcc mysql_count_ware ${warehousecount}/' 'build${ctr}_mariadb.tcl'"
			ssh -n "root@$host" "cd /usr/local/HammerDB && nohup ./hammerdbcli auto build${ctr}_mariadb.tcl 2>&1" | tr '\r' '\n' > build_mariadb_pod${ctr}.out &
			ctr=$((ctr + 1))
		done
		#
		# Wait for all the builds and loads to complete.
		#
		wait
	else
		#
		# Set it up, and build the dbase
		#
		mysql -p100yard- -e 'drop database tpcc;'
		cd /usr/local/HammerDB || exit
       		cp build_mariadb.tcl build${ctr}_mariadb.tcl
		sed -i "s/^diset connection mysql_host.*/diset connection mysql_host localhost/" build${ctr}_mariadb.tcl
		sed -i "s/^diset tpcc mysql_count_ware.*/diset tpcc mysql_count_ware ${warehousecount}/" build${ctr}_mariadb.tcl
		./hammerdbcli auto build${ctr}_mariadb.tcl 2>&1 | tr '\r' '\n' > build_mariadb_pod${ctr}.out
	fi
}

mariadb_test()
{
	warehousecount=${warehousecount:-1000}
	timeit install_it -s mariadb.service mariadb
	timeit build_it -b mariadb_build mariadb
	timeit run_hammerdb mariadb
	clean_it -s mariadb.service mariadb
}

mssql_build()
{
	local -i ctr=1
	if [[ -n "${dbhosts[*]:-}" ]] ; then
		local host
		for host in "${dbhosts[@]}" ; do
			ssh -n "root@$host" "cd /usr/local/HammerDB; cp build_mssql.tcl build${ctr}_mssql.tcl"
			ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/' build${ctr}_mssql.tcl"
			ssh -n "root@$host" "cd /usr/local/HammerDB; nohup ./hammerdbcli auto build${ctr}_mssql.tcl 2>&1" | tr '\r' '\n' > build_mssql${ctr}.out 2>&1 &
			ctr=$((ctr + 1))
		done
		wait
	else
		cd /usr/local/HammerDB || exit
		cp build_mssql.tcl "build${ctr}_mssql.tcl"
		sed -i "s/^diset tpcc mssqls_count_ware.*/diset tpcc mssqls_count_ware ${warehousecount}/" build${ctr}_mssql.tcl
		./hammerdbcli auto build${ctr}_mssql.tcl 2>&1  | tr '\r' '\n' > build_mssql${ctr}.out
	fi
}

mssql_test()
{
	warehousecount=${warehousecount:-500}
	timeit install_it -s mssql-server.service mssql
	timeit build_it -t 60 -b mssql_build mssql
	timeit run_hammerdb mssql
	clean_it -s mssql-server.service mssql
}

postgres_build()
{
	local -i ctr=1
	if [[ -n "${dbhosts[*]:-}" ]] ; then
		local host
		for host in "${dbhosts[@]}" ; do
			ssh -n "root@$host" "echo 'DROP DATABASE tpcc;' > input"
			ssh -n "root@$host" "echo 'DROP ROLE tpcc;' >> input"
			ssh -n "root@$host" "/usr/bin/psql -U postgres -d postgres -h ${host} -f input"
			ssh -n "root@$host" "cd /usr/local/HammerDB; cp build_pg.tcl build${ctr}_pg.tcl"
			ssh -n "root@$host" "cd /usr/local/HammerDB; sed -i 's/^diset connection pg_host.*/diset connection pg_host ${host}/' build${ctr}_pg.tcl"
			ssh -n "root@$host" "cd /usr/local/HammerDB; nohup ./hammerdbcli auto build${ctr}_pg.tcl" 2>&1 |tr '\r' '\n' > build_pg${ctr}.out
			ctr=$((ctr + 1))
		done
		wait
	else
		echo 'DROP DATABASE tpcc;' > input
		echo 'DROP ROLE tpcc;' >> input
		/usr/bin/psql -U postgres -d postgres -h "localhost" -f input
		cd /usr/local/HammerDB || exit 1
		cp build_pg.tcl build${ctr}_pg.tcl
		sed -i "s/^diset connection pg_host.*/diset connection pg_host localhost/" build${ctr}_pg.tcl
		./hammerdbcli auto build${ctr}_pg.tcl 2>&1 | tr '\r' '\n' > build_pg${ctr}.out
		ctr=$((ctr + 1))
	fi
	echo "Build done"
}

postgres_test()
{
	warehousecount=${warehousecount:-500}
	timeit install_it -s postgresql.service postgres
	timeit build_it -t 60 -b postgres_build postgres
	timeit run_hammerdb postgres
	clean_it -s postgresql.service postgres
}

#
# Were we passed an argument?
#

while getopts 'hH:d:M:m:w:u:t:r:Pp' opt "$@" ; do
	# shellcheck disable=SC2206
	case "$opt" in
		H) dbhosts+=(${OPTARG//,/ }) ;;
		d) disklist=$OPTARG ;;
		M) log_mount_point="-M $OPTARG" ;;
		m) mountpoint=$OPTARG ;;
		w) warehousecount=$OPTARG ;;
		u) usercount=$OPTARG ;;
		t) tests_to_run+=(${OPTARG//,/ }) ;;
		r) rundate=$OPTARG ;;
		P) install_packages='' ;;
		p) install_packages=' ' ;;
		h|*) usage "Unexpected option '$opt'" ;;
	esac
done
shift $((OPTIND-1))
if [[ -n "$*" ]] ; then
	do_install=0
	do_build=0
	do_run=0
	do_cleanup=0
	for arg in "$@" ; do
		case "$arg" in
			install) do_install=1 ;;
			build) do_build=1 ;;
			run) do_run=1 ;;
			cleanup) do_cleanup=1 ;;
			*) usage "Unexpected argument $arg" ;;
		esac
	done
fi

#
# If no test to run designated, bail.
#
[[ -z "${tests_to_run[*]:-}" ]] && usage "You need to designate a test to run"

cd "${0%/*}" || usage "Cannot cd ' '${0%/*}' ($0}"

((do_install)) && install_install_script
mount_check
#
# Determine what we are to run and run it.
#
for test in "${tests_to_run[@]}" ; do
	case "$test" in
		mariadb*) mariadb_test ;;
		mssql) mssql_test ;;
		postgres*) postgres_test ;;
		*) usage "Unknown test $test"
	esac
done

# Local Variables:
# sh-indentation: 8
# End:
